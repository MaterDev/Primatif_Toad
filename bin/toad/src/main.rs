use anyhow::Result;
use clap::{CommandFactory, Parser, Subcommand};
use colored::*;
use discovery::{find_projects, scan_all_projects};
use scaffold::{create_project, open_in_editor, ProjectConfig};
use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;

const VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Parser)]
#[command(name = "toad")]
#[command(about = "Primatif_Toad: Toad Control CLI", version = VERSION)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Create a new project directory
    Create {
        /// Name of the project
        name: String,

        /// Simulate the action without creating files
        #[arg(long, short = 'd')]
        dry_run: bool,
    },
    /// Find projects matching a query
    Reveal {
        /// Case-insensitive search query
        query: String,
    },
    /// Generate a project manifest for AI context (Shadow)
    Manifest,
    /// List all available commands
    List,
    /// Display version information and the Toad banner
    Version,
}

fn print_banner() {
    // Force colors to ensure they show up in all environments
    colored::control::set_override(true);

    let toad = r###"      _   _      
     (.)_(.)    
  _ (   _   ) _ 
 / \/`-----'\/ \ 
 __/  ^   ^  \__
"###;
    println!("{}", toad.green());
    println!(" {} v{}", "TOAD CONTROL".green().bold(), VERSION.white());
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    let root_dir = PathBuf::from("projects");

    match &cli.command {
        Commands::Create { name, dry_run } => {
            let config = ProjectConfig {
                name,
                root_dir: root_dir.clone(),
                dry_run: *dry_run,
            };

            create_project(config)?;

            if *dry_run {
                return Ok(());
            }

            println!("\nWould you like to open this project? [v]scode, [w]indsurf, or [n]o");
            print!("> ");
            io::stdout().flush()?;

            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            let choice = input.trim().to_lowercase();

            match choice.as_str() {
                "v" | "vscode" => open_in_editor(name, &root_dir, "vscode")?,
                "w" | "windsurf" => open_in_editor(name, &root_dir, "windsurf")?,
                _ => println!("Skipping editor launch."),
            }
        }
        Commands::Reveal { query } => {
            println!("Searching for projects matching '{}'...", query);
            let matches = find_projects(&root_dir, query, 30)?;

            if matches.is_empty() {
                println!("No projects found.");
            } else {
                for project in matches {
                    println!("- {}", project);
                }
            }
        }
        Commands::Manifest => {
            println!("Generating project manifest (Shadow Context)...");
            let projects = scan_all_projects(&root_dir)?;

            let mut output = String::new();
            output.push_str("# Project Context Manifest (Shadow)\n");
            output.push_str("> **Generated by:** `toad manifest`  \n");
            output.push_str(
                "> **Purpose:** Provide high-density semantic context for AI agents.  \n\n",
            );

            output.push_str("| Project | Stack | Essence (Extractive) | Semantic Tokens |\n");
            output.push_str("| :--- | :--- | :--- | :--- |\n");

            for p in projects {
                let essence = p.essence.unwrap_or_else(|| "No README found.".to_string());
                let tokens = if p.tokens.is_empty() {
                    "Pending harvest...".to_string()
                } else {
                    format!("`[{}]`", p.tokens.join(", "))
                };

                output.push_str(&format!(
                    "| **`{}`** | `{}` | {} | {} |\n",
                    p.name, p.stack, essence, tokens
                ));
            }

            let manifest_dir = PathBuf::from("shadows");

            if !manifest_dir.exists() {
                fs::create_dir(&manifest_dir)?;
            }

            let manifest_path = manifest_dir.join("MANIFEST.md");

            fs::write(&manifest_path, output)?;

            println!(
                "{} Manifest updated at: {:?}",
                "SUCCESS:".green().bold(),
                manifest_path
            );
        }
        Commands::List => {
            let mut cmd = Cli::command();
            cmd.print_help()?;
        }
        Commands::Version => {
            print_banner();
        }
    }

    Ok(())
}
